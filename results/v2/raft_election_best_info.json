{
  "id": "f17a52515573556d",
  "code": "/// Raft Leader Election - Lock-free implementation using atomics\n/// Fixed: single server election case where there are no other servers to vote\n\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, Ordering};\n\npub type ServerId = u64;\npub type Term = u64;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ServerState {\n    Follower,\n    Candidate,\n    Leader,\n}\n\nconst STATE_FOLLOWER: u64 = 0;\nconst STATE_CANDIDATE: u64 = 1;\nconst STATE_LEADER: u64 = 2;\n\nfn state_to_u64(s: ServerState) -> u64 {\n    match s {\n        ServerState::Follower => STATE_FOLLOWER,\n        ServerState::Candidate => STATE_CANDIDATE,\n        ServerState::Leader => STATE_LEADER,\n    }\n}\n\nfn u64_to_state(v: u64) -> ServerState {\n    match v {\n        STATE_FOLLOWER => ServerState::Follower,\n        STATE_CANDIDATE => ServerState::Candidate,\n        STATE_LEADER => ServerState::Leader,\n        _ => ServerState::Follower,\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum RaftError {\n    NotCandidate,\n    AlreadyVoted,\n    StaleTerm,\n    ClusterTooSmall,\n    ServerNotFound,\n}\n\n#[derive(Debug, Clone)]\npub struct VoteRequest {\n    pub term: Term,\n    pub candidate_id: ServerId,\n}\n\n#[derive(Debug, Clone)]\npub struct VoteResponse {\n    pub term: Term,\n    pub vote_granted: bool,\n    pub voter_id: ServerId,\n}\n\n#[derive(Debug, Clone)]\npub struct Heartbeat {\n    pub term: Term,\n    pub leader_id: ServerId,\n}\n\nconst TERM_BITS: u64 = 40;\nconst VOTED_BITS: u64 = 22;\nconst STATE_BITS: u64 = 2;\n\nconst STATE_MASK: u64 = (1 << STATE_BITS) - 1; // 0x3\nconst VOTED_MASK: u64 = (1 << VOTED_BITS) - 1; // 0x3FFFFF\nconst TERM_MASK: u64 = (1 << TERM_BITS) - 1;\n\n// Layout: [term(40) | voted_for(22) | state(2)]\nfn pack(term: u64, voted_for: Option<ServerId>, state: ServerState) -> u64 {\n    let t = term & TERM_MASK;\n    let v = match voted_for {\n        None => 0u64,\n        Some(id) => (id + 1) & VOTED_MASK,\n    };\n    let s = state_to_u64(state) & STATE_MASK;\n    (t << (VOTED_BITS + STATE_BITS)) | (v << STATE_BITS) | s\n}\n\nfn unpack_term(packed: u64) -> u64 {\n    (packed >> (VOTED_BITS + STATE_BITS)) & TERM_MASK\n}\n\nfn unpack_voted_for(packed: u64) -> Option<ServerId> {\n    let v = (packed >> STATE_BITS) & VOTED_MASK;\n    if v == 0 {\n        None\n    } else {\n        Some(v - 1)\n    }\n}\n\nfn unpack_state(packed: u64) -> ServerState {\n    u64_to_state(packed & STATE_MASK)\n}\n\nstruct ServerAtomic {\n    /// Packed: term(40) | voted_for(22) | state(2)\n    packed: AtomicU64,\n    /// Bitmask of votes received (supports up to 64 servers by index)\n    votes_received: AtomicU64,\n}\n\npub struct RaftElection {\n    servers: HashMap<ServerId, ServerAtomic>,\n    /// Map from ServerId to bit index (0..cluster_size)\n    id_to_bit: HashMap<ServerId, u32>,\n    cluster_size: usize,\n    next_id: AtomicU64,\n}\n\nimpl RaftElection {\n    pub fn new(server_ids: &[ServerId]) -> Self {\n        debug_assert!(!server_ids.is_empty(), \"Cluster must have at least one server\");\n        debug_assert!(server_ids.len() <= 64, \"Max 64 servers supported\");\n\n        let mut servers = HashMap::new();\n        let mut id_to_bit = HashMap::new();\n\n        for (idx, &id) in server_ids.iter().enumerate() {\n            id_to_bit.insert(id, idx as u32);\n            servers.insert(\n                id,\n                ServerAtomic {\n                    packed: AtomicU64::new(pack(0, None, ServerState::Follower)),\n                    votes_received: AtomicU64::new(0),\n                },\n            );\n        }\n\n        RaftElection {\n            cluster_size: servers.len(),\n            servers,\n            id_to_bit,\n            next_id: AtomicU64::new(server_ids.iter().max().copied().unwrap_or(0) + 1),\n        }\n    }\n\n    pub fn cluster_size(&self) -> usize {\n        self.cluster_size\n    }\n\n    pub fn quorum_size(&self) -> usize {\n        self.cluster_size / 2 + 1\n    }\n\n    pub fn get_state(&self, server_id: ServerId) -> Option<ServerState> {\n        self.servers\n            .get(&server_id)\n            .map(|s| unpack_state(s.packed.load(Ordering::SeqCst)))\n    }\n\n    pub fn get_term(&self, server_id: ServerId) -> Option<Term> {\n        self.servers\n            .get(&server_id)\n            .map(|s| unpack_term(s.packed.load(Ordering::SeqCst)))\n    }\n\n    pub fn get_leader(&self) -> Option<ServerId> {\n        for (&id, server) in &self.servers {\n            let packed = server.packed.load(Ordering::SeqCst);\n            if unpack_state(packed) == ServerState::Leader {\n                return Some(id);\n            }\n        }\n        None\n    }\n\n    pub fn timeout(&self, server_id: ServerId) -> Result<VoteRequest, RaftError> {\n        let server = self\n            .servers\n            .get(&server_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        let self_bit = self.id_to_bit[&server_id];\n\n        loop {\n            let old_packed = server.packed.load(Ordering::SeqCst);\n            let old_term = unpack_term(old_packed);\n\n            let new_term = old_term + 1;\n            let new_packed = pack(new_term, Some(server_id), ServerState::Candidate);\n\n            if server\n                .packed\n                .compare_exchange(old_packed, new_packed, Ordering::SeqCst, Ordering::SeqCst)\n                .is_ok()\n            {\n                // Set votes_received to just self\n                server.votes_received.store(1u64 << self_bit, Ordering::SeqCst);\n\n                // If single-server cluster, immediately become leader\n                if self.cluster_size == 1 {\n                    let leader_packed = pack(new_term, Some(server_id), ServerState::Leader);\n                    let _ = server.packed.compare_exchange(\n                        new_packed,\n                        leader_packed,\n                        Ordering::SeqCst,\n                        Ordering::SeqCst,\n                    );\n                }\n\n                return Ok(VoteRequest {\n                    term: new_term,\n                    candidate_id: server_id,\n                });\n            }\n            // CAS failed, retry\n        }\n    }\n\n    pub fn handle_vote_request(\n        &self,\n        server_id: ServerId,\n        request: &VoteRequest,\n    ) -> Result<VoteResponse, RaftError> {\n        let server = self\n            .servers\n            .get(&server_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        loop {\n            let old_packed = server.packed.load(Ordering::SeqCst);\n            let mut current_term = unpack_term(old_packed);\n            let mut voted_for = unpack_voted_for(old_packed);\n            let mut state = unpack_state(old_packed);\n\n            // If the request has a higher term, step down\n            if request.term > current_term {\n                current_term = request.term;\n                state = ServerState::Follower;\n                voted_for = None;\n            }\n\n            // Grant vote if: term matches, and we haven't voted or voted for this candidate\n            let vote_granted = request.term >= current_term\n                && (voted_for.is_none() || voted_for == Some(request.candidate_id));\n\n            if vote_granted {\n                voted_for = Some(request.candidate_id);\n            }\n\n            let new_packed = pack(current_term, voted_for, state);\n\n            if old_packed == new_packed {\n                // No change needed\n                return Ok(VoteResponse {\n                    term: current_term,\n                    vote_granted,\n                    voter_id: server_id,\n                });\n            }\n\n            if server\n                .packed\n                .compare_exchange(old_packed, new_packed, Ordering::SeqCst, Ordering::SeqCst)\n                .is_ok()\n            {\n                // If we stepped down, clear votes\n                if state == ServerState::Follower && unpack_state(old_packed) != ServerState::Follower {\n                    server.votes_received.store(0, Ordering::SeqCst);\n                }\n\n                return Ok(VoteResponse {\n                    term: current_term,\n                    vote_granted,\n                    voter_id: server_id,\n                });\n            }\n            // CAS failed, retry\n        }\n    }\n\n    pub fn handle_vote_response(\n        &self,\n        candidate_id: ServerId,\n        response: &VoteResponse,\n    ) -> Result<bool, RaftError> {\n        let server = self\n            .servers\n            .get(&candidate_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        loop {\n            let old_packed = server.packed.load(Ordering::SeqCst);\n            let current_term = unpack_term(old_packed);\n            let state = unpack_state(old_packed);\n\n            // If response has higher term, step down\n            if response.term > current_term {\n                let new_packed = pack(response.term, None, ServerState::Follower);\n                if server\n                    .packed\n                    .compare_exchange(old_packed, new_packed, Ordering::SeqCst, Ordering::SeqCst)\n                    .is_ok()\n                {\n                    server.votes_received.store(0, Ordering::SeqCst);\n                    return Ok(false);\n                }\n                continue; // retry\n            }\n\n            // Only process if still a candidate in the same term\n            if state != ServerState::Candidate || response.term != current_term {\n                return Ok(state == ServerState::Leader && response.term == current_term);\n            }\n\n            if response.vote_granted {\n                if let Some(&voter_bit) = self.id_to_bit.get(&response.voter_id) {\n                    let bit = 1u64 << voter_bit;\n                    // Atomically add the vote\n                    let old_votes = server.votes_received.fetch_or(bit, Ordering::SeqCst);\n                    let new_votes = old_votes | bit;\n                    let vote_count = new_votes.count_ones() as usize;\n\n                    if vote_count >= self.quorum_size() {\n                        // Try to become leader\n                        let current = server.packed.load(Ordering::SeqCst);\n                        if unpack_state(current) == ServerState::Candidate\n                            && unpack_term(current) == current_term\n                        {\n                            let leader_packed = pack(current_term, Some(candidate_id), ServerState::Leader);\n                            let _ = server.packed.compare_exchange(\n                                current,\n                                leader_packed,\n                                Ordering::SeqCst,\n                                Ordering::SeqCst,\n                            );\n                        }\n                        // Check if we actually became leader\n                        let final_packed = server.packed.load(Ordering::SeqCst);\n                        return Ok(\n                            unpack_state(final_packed) == ServerState::Leader\n                                && unpack_term(final_packed) == current_term,\n                        );\n                    }\n                }\n            }\n\n            return Ok(false);\n        }\n    }\n\n    pub fn handle_heartbeat(\n        &self,\n        server_id: ServerId,\n        heartbeat: &Heartbeat,\n    ) -> Result<(), RaftError> {\n        let server = self\n            .servers\n            .get(&server_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        loop {\n            let old_packed = server.packed.load(Ordering::SeqCst);\n            let current_term = unpack_term(old_packed);\n\n            if heartbeat.term >= current_term {\n                let voted_for = if heartbeat.term > current_term {\n                    None\n                } else {\n                    unpack_voted_for(old_packed)\n                };\n                let new_packed = pack(heartbeat.term, voted_for, ServerState::Follower);\n\n                if old_packed == new_packed {\n                    server.votes_received.store(0, Ordering::SeqCst);\n                    return Ok(());\n                }\n\n                if server\n                    .packed\n                    .compare_exchange(old_packed, new_packed, Ordering::SeqCst, Ordering::SeqCst)\n                    .is_ok()\n                {\n                    server.votes_received.store(0, Ordering::SeqCst);\n                    return Ok(());\n                }\n                continue;\n            }\n\n            return Ok(());\n        }\n    }\n\n    pub fn create_heartbeat(&self, leader_id: ServerId) -> Result<Heartbeat, RaftError> {\n        let server = self\n            .servers\n            .get(&leader_id)\n            .ok_or(RaftError::ServerNotFound)?;\n\n        let packed = server.packed.load(Ordering::SeqCst);\n\n        if unpack_state(packed) != ServerState::Leader {\n            return Err(RaftError::NotCandidate);\n        }\n\n        Ok(Heartbeat {\n            term: unpack_term(packed),\n            leader_id,\n        })\n    }\n\n    pub fn run_election(&self, candidate_id: ServerId) -> Result<bool, RaftError> {\n        let vote_request = self.timeout(candidate_id)?;\n\n        // Check if already won (single server case)\n        if self.get_state(candidate_id) == Some(ServerState::Leader) {\n            return Ok(true);\n        }\n\n        let other_servers: Vec<ServerId> = self\n            .servers\n            .keys()\n            .filter(|&&id| id != candidate_id)\n            .copied()\n            .collect();\n\n        for &other_id in &other_servers {\n            let response = self.handle_vote_request(other_id, &vote_request)?;\n            let won = self.handle_vote_response(candidate_id, &response)?;\n            if won {\n                return Ok(true);\n            }\n        }\n\n        Ok(self.get_state(candidate_id) == Some(ServerState::Leader))\n    }\n}",
  "score": 490.0,
  "correct": true,
  "generation": 3,
  "parent_id": "79bf8896fcbff6e2",
  "island": 2,
  "level_reached": 3,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (8.4s)\n- miri: PASS (35.2s)\n- loom: PASS (11.6s)\n- DST: PASS (12.6s)\n",
  "model": "opus-hot"
}