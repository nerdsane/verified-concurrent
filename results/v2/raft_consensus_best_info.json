{
  "id": "1da7ecf55a8dcb97",
  "code": "/// Raft Consensus - Lock-free implementation using atomics and CAS operations\n/// Progress guarantee: LockFree (CAS-based state transitions, wait-free reads)\nuse std::sync::atomic::{AtomicU64, AtomicPtr, Ordering};\nuse std::collections::HashMap;\nuse std::ptr;\n\npub type NodeId = u64;\npub type Term = u64;\npub type LogIndex = u64;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum NodeState {\n    Follower,\n    Candidate,\n    Leader,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum RaftError {\n    NotLeader,\n    NotCandidate,\n    StaleTerm,\n    NodeNotFound,\n    LogInconsistency,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LogEntry {\n    pub index: LogIndex,\n    pub term: Term,\n    pub data: Vec<u8>,\n}\n\n#[derive(Debug, Clone)]\npub enum Message {\n    RequestVote {\n        term: Term,\n        candidate_id: NodeId,\n        last_log_index: LogIndex,\n        last_log_term: Term,\n    },\n    RequestVoteResponse {\n        term: Term,\n        voter_id: NodeId,\n        vote_granted: bool,\n    },\n    AppendEntries {\n        term: Term,\n        leader_id: NodeId,\n        prev_log_index: LogIndex,\n        prev_log_term: Term,\n        entries: Vec<LogEntry>,\n        leader_commit: LogIndex,\n    },\n    AppendEntriesResponse {\n        term: Term,\n        follower_id: NodeId,\n        success: bool,\n        match_index: LogIndex,\n    },\n}\n\n#[derive(Debug, Clone, Default)]\npub struct Ready {\n    pub messages: Vec<(NodeId, Message)>,\n    pub committed_entries: Vec<LogEntry>,\n    pub should_persist: bool,\n}\n\n/// Inner mutable state, swapped atomically via AtomicPtr (CAS-based, lock-free)\n#[derive(Clone)]\nstruct NodeInner {\n    id: NodeId,\n    peers: Vec<NodeId>,\n    state: NodeState,\n    current_term: Term,\n    voted_for: Option<NodeId>,\n    log: Vec<LogEntry>,\n    commit_index: LogIndex,\n    last_applied: LogIndex,\n    next_index: HashMap<NodeId, LogIndex>,\n    match_index: HashMap<NodeId, LogIndex>,\n    votes_received: Vec<NodeId>,\n    election_elapsed: u64,\n    heartbeat_elapsed: u64,\n    election_timeout: u64,\n    heartbeat_interval: u64,\n    pending_messages: Vec<(NodeId, Message)>,\n    pending_committed: Vec<LogEntry>,\n}\n\npub struct RaftNode {\n    // Wait-free read caches\n    cached_id: AtomicU64,\n    cached_term: AtomicU64,\n    cached_state: AtomicU64,\n    cached_commit_index: AtomicU64,\n    cached_log_len: AtomicU64,\n    // Lock-free mutable state via CAS on pointer\n    state_ptr: AtomicPtr<NodeInner>,\n}\n\n// Manual Send+Sync since we manage the pointer carefully\nunsafe impl Send for RaftNode {}\nunsafe impl Sync for RaftNode {}\n\nimpl Drop for RaftNode {\n    fn drop(&mut self) {\n        let ptr = self.state_ptr.load(Ordering::Acquire);\n        if !ptr.is_null() {\n            unsafe { drop(Box::from_raw(ptr)); }\n        }\n    }\n}\n\nimpl RaftNode {\n    pub fn new(id: NodeId, peers: Vec<NodeId>) -> Self {\n        let inner = Box::new(NodeInner {\n            id,\n            peers,\n            state: NodeState::Follower,\n            current_term: 0,\n            voted_for: None,\n            log: Vec::new(),\n            commit_index: 0,\n            last_applied: 0,\n            next_index: HashMap::new(),\n            match_index: HashMap::new(),\n            votes_received: Vec::new(),\n            election_elapsed: 0,\n            heartbeat_elapsed: 0,\n            election_timeout: 10,\n            heartbeat_interval: 3,\n            pending_messages: Vec::new(),\n            pending_committed: Vec::new(),\n        });\n        RaftNode {\n            cached_id: AtomicU64::new(id),\n            cached_term: AtomicU64::new(0),\n            cached_state: AtomicU64::new(0),\n            cached_commit_index: AtomicU64::new(0),\n            cached_log_len: AtomicU64::new(0),\n            state_ptr: AtomicPtr::new(Box::into_raw(inner)),\n        }\n    }\n\n    // Wait-free reads\n    pub fn id(&self) -> NodeId {\n        self.cached_id.load(Ordering::Acquire)\n    }\n\n    pub fn state(&self) -> NodeState {\n        match self.cached_state.load(Ordering::Acquire) {\n            1 => NodeState::Candidate,\n            2 => NodeState::Leader,\n            _ => NodeState::Follower,\n        }\n    }\n\n    pub fn term(&self) -> Term {\n        self.cached_term.load(Ordering::Acquire)\n    }\n\n    pub fn commit_index(&self) -> LogIndex {\n        self.cached_commit_index.load(Ordering::Acquire)\n    }\n\n    pub fn log_len(&self) -> u64 {\n        self.cached_log_len.load(Ordering::Acquire)\n    }\n\n    fn state_to_u64(s: NodeState) -> u64 {\n        match s {\n            NodeState::Follower => 0,\n            NodeState::Candidate => 1,\n            NodeState::Leader => 2,\n        }\n    }\n\n    fn sync_caches(&self, inner: &NodeInner) {\n        self.cached_term.store(inner.current_term, Ordering::Release);\n        self.cached_state.store(Self::state_to_u64(inner.state), Ordering::Release);\n        self.cached_commit_index.store(inner.commit_index, Ordering::Release);\n        self.cached_log_len.store(inner.log.len() as u64, Ordering::Release);\n    }\n\n    /// CAS-based state update: read current, clone, mutate, CAS swap.\n    /// Returns old Box for reclamation on success, or None on CAS failure (retry).\n    fn cas_update<F>(&self, mut f: F) where F: FnMut(&mut NodeInner) {\n        loop {\n            let old_ptr = self.state_ptr.load(Ordering::Acquire);\n            if old_ptr.is_null() {\n                return;\n            }\n            // Clone the current state\n            let old_ref = unsafe { &*old_ptr };\n            let mut new_inner = old_ref.clone();\n            // Apply mutation\n            f(&mut new_inner);\n            // Update caches\n            self.sync_caches(&new_inner);\n            let new_ptr = Box::into_raw(Box::new(new_inner));\n            // CAS\n            match self.state_ptr.compare_exchange(old_ptr, new_ptr, Ordering::AcqRel, Ordering::Acquire) {\n                Ok(_old) => {\n                    // Successfully swapped; reclaim old\n                    unsafe { drop(Box::from_raw(old_ptr)); }\n                    return;\n                }\n                Err(_) => {\n                    // CAS failed, reclaim the new allocation and retry\n                    unsafe { drop(Box::from_raw(new_ptr)); }\n                    // Loop and retry - this is lock-free (progress guaranteed if no contention)\n                }\n            }\n        }\n    }\n\n    /// Read current state snapshot\n    fn read_state<R, F>(&self, f: F) -> R where F: FnOnce(&NodeInner) -> R {\n        let ptr = self.state_ptr.load(Ordering::Acquire);\n        assert!(!ptr.is_null());\n        let inner = unsafe { &*ptr };\n        f(inner)\n    }\n\n    fn quorum_size(cluster_size: usize) -> usize {\n        cluster_size / 2 + 1\n    }\n\n    pub fn tick(&self) {\n        self.cas_update(|inner| {\n            match inner.state {\n                NodeState::Leader => {\n                    inner.heartbeat_elapsed += 1;\n                    if inner.heartbeat_elapsed >= inner.heartbeat_interval {\n                        inner.heartbeat_elapsed = 0;\n                        Self::send_heartbeats(inner);\n                    }\n                }\n                NodeState::Follower | NodeState::Candidate => {\n                    inner.election_elapsed += 1;\n                    if inner.election_elapsed >= inner.election_timeout {\n                        Self::start_election(inner);\n                    }\n                }\n            }\n        });\n    }\n\n    pub fn propose(&self, data: Vec<u8>) -> Result<u64, RaftError> {\n        // First check state wait-free\n        if self.state() != NodeState::Leader {\n            return Err(RaftError::NotLeader);\n        }\n\n        let mut result = Err(RaftError::NotLeader);\n        self.cas_update(|inner| {\n            if inner.state != NodeState::Leader {\n                result = Err(RaftError::NotLeader);\n                return;\n            }\n\n            let index = inner.log.len() as u64 + 1;\n            let term = inner.current_term;\n            let entry = LogEntry { index, term, data: data.clone() };\n            inner.log.push(entry);\n\n            let self_id = inner.id;\n            inner.match_index.insert(self_id, index);\n\n            Self::send_append_entries(inner);\n            result = Ok(index);\n        });\n        result\n    }\n\n    pub fn step(&self, message: Message) -> Result<(), RaftError> {\n        self.cas_update(|inner| {\n            match message.clone() {\n                Message::RequestVote {\n                    term,\n                    candidate_id,\n                    last_log_index,\n                    last_log_term,\n                } => {\n                    Self::handle_request_vote(inner, term, candidate_id, last_log_index, last_log_term);\n                }\n                Message::RequestVoteResponse {\n                    term,\n                    voter_id,\n                    vote_granted,\n                } => {\n                    Self::handle_vote_response(inner, term, voter_id, vote_granted);\n                }\n                Message::AppendEntries {\n                    term,\n                    leader_id,\n                    prev_log_index,\n                    prev_log_term,\n                    entries,\n                    leader_commit,\n                } => {\n                    Self::handle_append_entries(inner, term, leader_id, prev_log_index, prev_log_term, entries, leader_commit);\n                }\n                Message::AppendEntriesResponse {\n                    term,\n                    follower_id,\n                    success,\n                    match_index,\n                } => {\n                    Self::handle_append_entries_response(inner, term, follower_id, success, match_index);\n                }\n            }\n        });\n        Ok(())\n    }\n\n    pub fn ready(&self) -> Ready {\n        self.read_state(|inner| {\n            Ready {\n                messages: inner.pending_messages.clone(),\n                committed_entries: inner.pending_committed.clone(),\n                should_persist: !inner.pending_messages.is_empty() || !inner.pending_committed.is_empty(),\n            }\n        })\n    }\n\n    pub fn advance(&self, _ready: Ready) {\n        self.cas_update(|inner| {\n            inner.pending_messages.clear();\n            inner.pending_committed.clear();\n        });\n    }\n\n    fn last_log_info(inner: &NodeInner) -> (LogIndex, Term) {\n        inner.log.last().map(|e| (e.index, e.term)).unwrap_or((0, 0))\n    }\n\n    fn start_election(inner: &mut NodeInner) {\n        inner.current_term += 1;\n        inner.state = NodeState::Candidate;\n        let self_id = inner.id;\n        inner.voted_for = Some(self_id);\n        inner.votes_received = vec![self_id];\n        inner.election_elapsed = 0;\n\n        let cluster_size = inner.peers.len() + 1;\n        if inner.votes_received.len() >= Self::quorum_size(cluster_size) {\n            Self::become_leader(inner);\n            return;\n        }\n\n        let (last_log_index, last_log_term) = Self::last_log_info(inner);\n        let term = inner.current_term;\n        let candidate_id = inner.id;\n\n        let peers: Vec<NodeId> = inner.peers.clone();\n        for peer in peers {\n            inner.pending_messages.push((\n                peer,\n                Message::RequestVote {\n                    term,\n                    candidate_id,\n                    last_log_index,\n                    last_log_term,\n                },\n            ));\n        }\n    }\n\n    fn send_heartbeats(inner: &mut NodeInner) {\n        let peers: Vec<NodeId> = inner.peers.clone();\n        let term = inner.current_term;\n        let leader_id = inner.id;\n        let leader_commit = inner.commit_index;\n\n        for peer in peers {\n            let next_idx = inner.next_index.get(&peer).copied().unwrap_or(1);\n            let prev_log_index = next_idx.saturating_sub(1);\n            let prev_log_term = if prev_log_index == 0 {\n                0\n            } else {\n                inner.log.get((prev_log_index - 1) as usize).map(|e| e.term).unwrap_or(0)\n            };\n\n            let entries: Vec<LogEntry> = inner.log.iter().filter(|e| e.index >= next_idx).cloned().collect();\n\n            inner.pending_messages.push((\n                peer,\n                Message::AppendEntries {\n                    term,\n                    leader_id,\n                    prev_log_index,\n                    prev_log_term,\n                    entries,\n                    leader_commit,\n                },\n            ));\n        }\n    }\n\n    fn send_append_entries(inner: &mut NodeInner) {\n        Self::send_heartbeats(inner);\n    }\n\n    fn handle_request_vote(\n        inner: &mut NodeInner,\n        term: Term,\n        candidate_id: NodeId,\n        last_log_index: LogIndex,\n        last_log_term: Term,\n    ) {\n        if term > inner.current_term {\n            inner.current_term = term;\n            inner.state = NodeState::Follower;\n            inner.voted_for = None;\n            inner.votes_received.clear();\n        }\n\n        let (my_last_index, my_last_term) = Self::last_log_info(inner);\n        let log_ok = last_log_term > my_last_term\n            || (last_log_term == my_last_term && last_log_index >= my_last_index);\n\n        let vote_granted = term >= inner.current_term\n            && (inner.voted_for.is_none() || inner.voted_for == Some(candidate_id))\n            && log_ok;\n\n        if vote_granted {\n            inner.voted_for = Some(candidate_id);\n            inner.election_elapsed = 0;\n        }\n\n        let self_id = inner.id;\n        let current_term = inner.current_term;\n        inner.pending_messages.push((\n            candidate_id,\n            Message::RequestVoteResponse {\n                term: current_term,\n                voter_id: self_id,\n                vote_granted,\n            },\n        ));\n    }\n\n    fn handle_vote_response(inner: &mut NodeInner, term: Term, voter_id: NodeId, vote_granted: bool) {\n        if term > inner.current_term {\n            inner.current_term = term;\n            inner.state = NodeState::Follower;\n            inner.voted_for = None;\n            inner.votes_received.clear();\n            return;\n        }\n\n        if inner.state != NodeState::Candidate || term != inner.current_term {\n            return;\n        }\n\n        if vote_granted && !inner.votes_received.contains(&voter_id) {\n            inner.votes_received.push(voter_id);\n        }\n\n        let cluster_size = inner.peers.len() + 1;\n        if inner.votes_received.len() >= Self::quorum_size(cluster_size) {\n            Self::become_leader(inner);\n        }\n    }\n\n    fn become_leader(inner: &mut NodeInner) {\n        inner.state = NodeState::Leader;\n        inner.heartbeat_elapsed = 0;\n\n        let last_log_idx = inner.log.len() as u64 + 1;\n        let self_id = inner.id;\n        let self_log_len = inner.log.len() as u64;\n        let peers: Vec<NodeId> = inner.peers.clone();\n        for peer in &peers {\n            inner.next_index.insert(*peer, last_log_idx);\n            inner.match_index.insert(*peer, 0);\n        }\n        inner.match_index.insert(self_id, self_log_len);\n\n        Self::send_heartbeats(inner);\n    }\n\n    fn handle_append_entries(\n        inner: &mut NodeInner,\n        term: Term,\n        leader_id: NodeId,\n        prev_log_index: LogIndex,\n        prev_log_term: Term,\n        entries: Vec<LogEntry>,\n        leader_commit: LogIndex,\n    ) {\n        if term > inner.current_term {\n            inner.current_term = term;\n            inner.voted_for = None;\n            inner.votes_received.clear();\n        }\n\n        if term < inner.current_term {\n            let self_id = inner.id;\n            let current_term = inner.current_term;\n            inner.pending_messages.push((\n                leader_id,\n                Message::AppendEntriesResponse {\n                    term: current_term,\n                    follower_id: self_id,\n                    success: false,\n                    match_index: 0,\n                },\n            ));\n            return;\n        }\n\n        inner.state = NodeState::Follower;\n        inner.election_elapsed = 0;\n\n        if prev_log_index > 0 {\n            let has_entry = inner\n                .log\n                .get((prev_log_index - 1) as usize)\n                .map(|e| e.term == prev_log_term)\n                .unwrap_or(false);\n            if !has_entry {\n                let self_id = inner.id;\n                let current_term = inner.current_term;\n                inner.pending_messages.push((\n                    leader_id,\n                    Message::AppendEntriesResponse {\n                        term: current_term,\n                        follower_id: self_id,\n                        success: false,\n                        match_index: 0,\n                    },\n                ));\n                return;\n            }\n        }\n\n        for entry in &entries {\n            let idx = (entry.index - 1) as usize;\n            if idx < inner.log.len() {\n                if inner.log[idx].term != entry.term {\n                    inner.log.truncate(idx);\n                    inner.log.push(entry.clone());\n                }\n            } else {\n                inner.log.push(entry.clone());\n            }\n        }\n\n        if leader_commit > inner.commit_index {\n            let last_new_idx = entries.last().map(|e| e.index).unwrap_or(inner.log.len() as u64);\n            inner.commit_index = leader_commit.min(last_new_idx);\n            Self::apply_committed(inner);\n        }\n\n        let match_idx = inner.log.len() as u64;\n        let self_id = inner.id;\n        let current_term = inner.current_term;\n        inner.pending_messages.push((\n            leader_id,\n            Message::AppendEntriesResponse {\n                term: current_term,\n                follower_id: self_id,\n                success: true,\n                match_index: match_idx,\n            },\n        ));\n    }\n\n    fn handle_append_entries_response(\n        inner: &mut NodeInner,\n        term: Term,\n        follower_id: NodeId,\n        success: bool,\n        match_index: LogIndex,\n    ) {\n        if term > inner.current_term {\n            inner.current_term = term;\n            inner.state = NodeState::Follower;\n            inner.voted_for = None;\n            inner.votes_received.clear();\n            return;\n        }\n\n        if inner.state != NodeState::Leader || term != inner.current_term {\n            return;\n        }\n\n        if success {\n            let current_match = inner.match_index.get(&follower_id).copied().unwrap_or(0);\n            if match_index > current_match {\n                inner.next_index.insert(follower_id, match_index + 1);\n                inner.match_index.insert(follower_id, match_index);\n            }\n            Self::try_advance_commit(inner);\n        } else {\n            let next = inner.next_index.get(&follower_id).copied().unwrap_or(1);\n            let new_next = next.saturating_sub(1).max(1);\n            inner.next_index.insert(follower_id, new_next);\n\n            // Immediately retry\n            let term = inner.current_term;\n            let leader_id = inner.id;\n            let leader_commit = inner.commit_index;\n            let prev_log_index = new_next.saturating_sub(1);\n            let prev_log_term = if prev_log_index == 0 {\n                0\n            } else {\n                inner.log.get((prev_log_index - 1) as usize).map(|e| e.term).unwrap_or(0)\n            };\n            let entries: Vec<LogEntry> = inner.log.iter().filter(|e| e.index >= new_next).cloned().collect();\n            inner.pending_messages.push((\n                follower_id,\n                Message::AppendEntries {\n                    term,\n                    leader_id,\n                    prev_log_index,\n                    prev_log_term,\n                    entries,\n                    leader_commit,\n                },\n            ));\n        }\n    }\n\n    fn try_advance_commit(inner: &mut NodeInner) {\n        let cluster_size = inner.peers.len() + 1;\n        let quorum = Self::quorum_size(cluster_size);\n        let current_term = inner.current_term;\n        let log_len = inner.log.len() as u64;\n\n        for n in (inner.commit_index + 1..=log_len).rev() {\n            let replicated = inner.match_index.values().filter(|&&mi| mi >= n).count();\n\n            if replicated >= quorum {\n                if let Some(entry) = inner.log.get((n - 1) as usize) {\n                    if entry.term == current_term {\n                        inner.commit_index = n;\n                        Self::apply_committed(inner);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    fn apply_committed(inner: &mut NodeInner) {\n        while inner.last_applied < inner.commit_index {\n            inner.last_applied += 1;\n            if let Some(entry) = inner.log.get((inner.last_applied - 1) as usize) {\n                inner.pending_committed.push(entry.clone());\n            }\n        }\n    }\n}",
  "score": 490.0,
  "correct": true,
  "generation": 7,
  "parent_id": "8c5a1dd137189782",
  "island": 0,
  "level_reached": 3,
  "progress": "LockFree",
  "feedback": "## Cascade Results:\n- rustc: PASS (8.8s)\n- miri: PASS (17.1s)\n- loom: PASS (26.6s)\n- DST: PASS (24.3s)\n",
  "model": "opus"
}